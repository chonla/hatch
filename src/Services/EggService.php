<?php

namespace App\Services;

class EggService {
    function __construct() {
        $this->c = new \Colors\Color();
        $this->c->setUserStyles(
            [
                "err" => ["red", "bold"],
                "label" => ["green", "bold"],
                "default" => ["white"],
            ]
        );
    }

    function create($eggfile) {
        $this->text("Hatching", sprintf("Creating a new egg file: %s", $eggfile));

        if (file_exists($eggfile)) {
            $this->err(sprintf("File %s already exists. Please use other name or remove --new option to hatch it.", $eggfile));
            return;
        }

        $content = [
            "name" => sprintf("%s RESTful API", ucfirst(basename($eggfile, ".egg"))),
            "description" => "Egg file generated by Hatch.",
            "compiled" => "./compiled",
            "database" => [
                "dsn" => "sqlite:./db/db.sq3",
            ],
            "cors" => [
                "origin" => ["*"],
                "methods" => ["GET", "POST", "PUT", "PATCH", "DELETE"],
                "headers.allow" => [],
                "headers.expose" => [],
                "credentials" => false,
                "cache" => 0,
            ],
            "entities" => [
                "untitled_table" => [
                    "field1" => "short_text",
                    "field2" => "long_text",
                ],
            ],
            "migration" => [
                "untitled_table" => [
                    [
                        "field1" => "Hello",
                        "field2" => "Thank you for using Hatch.",
                    ],
                ],
            ],
        ];

        $json = json_encode($content, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
        file_put_contents($eggfile, $json);

        // Done
        $this->text("Hatching", "Done. Chirp chirp!");

        $this->text("Hatching", "Thank you for creating a new eggs.");
        $this->text(" -", sprintf("You may edit the egg \"%s\" and hatch it when you are ready.", $eggfile));
        $this->text("Hatching", "Enjoy RESTful API from Hatch!");
    }

    function hatch($eggfile) {
        $this->text("Hatching", $eggfile);

        if (!file_exists($eggfile)) {
            $this->err(sprintf("Expecting %s to be an existing file but it does not. Please check if the file exists or use --new option to create a new egg file.", $eggfile));
            return;
        }

        $decoder = new \Webmozart\Json\JsonDecoder();
        $decoder->setObjectDecoding(\Webmozart\Json\JsonDecoder::ASSOC_ARRAY);
        
        $egg = $decoder->decodeFile($eggfile);

        // Create temp folder
        $temp_path = dirname(dirname(__DIR__)) . '/.tmp';
        if (!is_dir($temp_path)) {
            @mkdir($temp_path, 0777, true);
        }

        // Create compiled output
        $this->text("Hatching", "Setting up compiled space.");
        $compiled_path = array_key_exists("compiled", $egg)?$egg["compiled"]:"./compiled";
        if ($compiled_path == "") {
            $compiled_path = "./";
        }
        if (!is_dir($compiled_path)) {
            @mkdir($compiled_path, 0777, true);
        }
        $meta_path = getcwd() . "/meta";
        chdir($compiled_path);

        $this->text("Hatching", "Constructing database.");
        // Create Egglets
        if (!array_key_exists("database", $egg) || !array_key_exists("dsn", $egg["database"]) || $egg["database"]["dsn"] === "") {
            $this->err("DSN is required to create Egglet, but no DSN is specified.");
            return;
        }

        $this->text("  -", "Determining entities.");
        $egglet = new EggletService();
        list($dbtype, $dummy) = explode(":", $egg["database"]["dsn"]);
        $egglet->set_db_type($dbtype);

        $entities = [];
        foreach ($egg["entities"] as $name => $entity) {
            $result = $egglet->compile($name, $entity);
            for ($i = 0, $n = count($result); $i < $n; $i++) {
                $entities[] = $result[$i];
            }
        }

        $meta = [];
        foreach ($egg["entities"] as $name => $entity) {
            $result = $egglet->meta($name, $entity);
            $meta = array_merge($meta, $result);
        }
        $this->export_meta($meta, $meta_path);

        $egglet_count = count($entities);
        if ($egglet_count === 0) {
            $this->err("Nothing to be hatched?");
            return;
        }

        $this->text("Hatching", sprintf("Incubating %s egglet%s.", $egglet_count, $egglet_count==1?"":"s"));

        if (!$this->incubate($egg["database"]["dsn"], $entities)) {
            $this->err("Unable to create tables to database.");
            return;
        }

        // Create composer file
        $this->text("Hatching", "Templating composer.");

        $proj_name = array_key_exists("name", $egg)?$egg["name"]:"My App";
        $proj_description = array_key_exists("description", $egg)?$egg["description"]:"My App generated from Hatch.";
        $proj = [
            "name" => $proj_name,
            "description" => $proj_description,
            "autoload" => [
                "psr-4" => [
                    "App\\"=> "src",
                ],
            ],
            "require" => [
                "slim/slim" => "^3.0",
                "tuupola/cors-middleware" => "^0.5",
            ],
        ];

        $encoder = new \Webmozart\Json\JsonEncoder();
        $encoder->setPrettyPrinting(true);
        $encoder->setEscapeSlash(false);

        $encoder->encodeFile($proj, "./composer.json");

        $this->text("Hatching", "Ensuring the latest version of composer is ready.");
        $composer = new ComposerService();
        $composer->set_path($temp_path);
        if (!$composer->ensure_available()) {
            $this->err("Unable to download composer.");
            return;
        }
        if (!$composer->install_composer()) {
            $this->err("Unable to install composer.");
            return;
        }
        if (!$composer->install_deps()) {
            $this->err("Unable to install dependencies. Please go to output folder and run \"composer install\" manually.");
            return;
        }

        if (!$composer->update_deps()) {
            $this->err("Unable to update dependencies. Please go to output folder and run \"composer install\" manually.");
            return;
        }

        // Template application
        $this->text("Hatching", "Scaffolding application.");
        $db_user = array_key_exists("user", $egg["database"])?$egg["database"]["user"]:"";
        $db_password = array_key_exists("password", $egg["database"])?$egg["database"]["password"]:"";

        $cors_origin = ["*"];
        $cors_methods = ["GET", "POST", "PUT", "PATCH", "DELETE"];
        $cors_headers_allow = [];
        $cors_headers_expose = [];
        $cors_credentials = false;
        $cors_cache = 0;
        if (array_key_exists("cors", $egg)) {
            $cors_origin = array_key_exists("origin", $egg["cors"])?$egg["cors"]["origin"]:["*"];
            $cors_methods = array_key_exists("methods", $egg["cors"])?$egg["cors"]["methods"]:["GET", "POST", "PUT", "PATCH", "DELETE"];
            $cors_headers_allow = array_key_exists("headers.allow", $egg["cors"])?$egg["cors"]["headers.allow"]:[];
            $cors_headers_expose = array_key_exists("headers.expose", $egg["cors"])?$egg["cors"]["headers.expose"]:[];
            $cors_credentials = array_key_exists("credentials", $egg["cors"])?$egg["cors"]["credentials"]:false;
            $cors_cache = array_key_exists("cache", $egg["cors"])?$egg["cors"]["cache"]:0;
        }

        $a = new AppService("../data", [
            "db_dsn" => $egg["database"]["dsn"],
            "db_user" => $db_user,
            "db_password" => $db_password,
            "cors_origin" => $cors_origin,
            "cors_methods" => $cors_methods,
            "cors_headers_allow" => $cors_headers_allow,
            "cors_headers_expose" => $cors_headers_expose,
            "cors_credentials" => $cors_credentials,
            "cors_cache" => $cors_cache,
            "egglet" => $egglet,
        ]);

        $this->text("  -", "Scaffolding output folders.");
        $a->scaffold();

        $this->text("  -", "Scaffolding application core.");
        $a->base();

        $this->text("  -", "Scaffolding engine.");
        $a->generate($egg["entities"]);

        // Migration
        if (array_key_exists("migration", $egg)) {
            $this->text("Hatching", "Migrating data");

            $data = [];
            foreach($egg["migration"] as $name => $values) {
                $result = $egglet->prepare_data($name, $egg["entities"][$name], $values);
                if ($result !== FALSE) {
                    for ($i = 0, $n = count($result); $i < $n; $i++) {
                        $data[] = $result[$i];
                    }
                } else {
                    $this->err("Unable to collect data being imported. Data structure may no be compatible with egg schema. Please verify your data and re-hatch.");
                    return;
                }
            }

            $data_count = count($data);
            if ($data_count === 0) {
                $this->text("  -", "Nothing to be migrated?");
            } else {
                $this->text("  -", sprintf("Importing %s record%s.", $data_count, $data_count==1?"":"s"));

                if (!$this->import_data($egg["database"]["dsn"], $data)) {
                    $this->err("Unable to import data.");
                    return;
                }
            }
        }

        // Done
        $this->text("Hatching", "Done. Chirp chirp!");

        $this->text("Hatching", "Thank you for hatching some eggs.");
        $this->text("  -", sprintf("You may copy all content in path %s to your server.", $compiled_path));
        $this->text("  -", "If you are using Shelf, you can use meta data in \"meta/ng2\" directory to generate form in Shelf.");
        $this->text("Hatching", "Enjoy RESTful API from Hatch!");
    }

    private function incubate($to, $entities) {
        return $this->bulk_execute_sql($to, $entities);
    }

    private function export_meta($meta, $meta_path) {
        $m = json_encode($meta, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);

        // write meta
        $path = sprintf("%s/json", $meta_path);
        if (!is_dir($path)) {
            @mkdir($path, 0777, true);
        }
        file_put_contents(sprintf("%s/meta.json", $path), $m);

        // write ng2
        $path = sprintf("%s/ng2", $meta_path);
        if (!is_dir($path)) {
            @mkdir($path, 0777, true);
        }
        $tmpl =<<<EOTMPL
import { Injectable } from '@angular/core';

@Injectable()
export class HatchMetaConfig {
    private config: Object = %s;
    constructor() {}

    all(key: any) {
        return this.config[key];
    }

    get(key: any) {
        let meta = this.config[key];
        let pri = [];
        if (meta.attributes && meta.attributes.private) {
            pri = meta.attributes.private;
        }
        if (pri.length > 0) {
            meta.fields = meta.fields.filter((o) => {
                return pri.indexOf(o.name) === -1;
            })
        }
        return meta;
    }

    keys() {
        return Object.keys(this.config);
    }

    fields(key: any) {
        let meta = this.get(key);
        return meta.fields;
    }
}
EOTMPL;
        file_put_contents(sprintf("%s/hatchmeta.config.ts", $path), sprintf($tmpl, $m));
    }

    public function import_data($to, $data) {
        return $this->bulk_execute_sql($to, $data);
    }

    private function bulk_execute_sql($to, $sqls) {
        try {
            // Create path for sqlite if need.
            if (preg_match('/^sqlite:(.+)$/', $to, $match)) {
                $sqlite = $match[1];
                if (!file_exists($sqlite)) {
                    $dir = dirname($sqlite);
                    if (!is_dir($dir)) {
                        @mkdir($dir, 0777, true);
                    }
                }
            }

            // Spin things up
            $db = new \PDO($to);
            $lastid = 0;

            foreach ($sqls as $sql) {
                if ($sql[0] === "\t") {
                    $sql = preg_replace("/\{\{%last_id%\}\}/", $lastid, $sql, -1);
                    $db->query($sql);
                } else {
                    $db->query($sql);
                    $lastid = $db->lastInsertId();
                }
            }
        } catch(PDOException $e) {
            $this->err($e);
            return false;
        }
        return true;
    }

    private function text($label, $msg) {
        $this->outln("<label>${label} ></label> <default>${msg}</default>");
    }

    private function err($msg) {
        $this->outln("<err>Error ></err> <default>${msg}</default>");
    }

    private function outln($msg) {
        echo $this->c->colorize($msg) . PHP_EOL;
    }
}